# Лабораторная работа №6. Балансирование нагрузки в облаке и авто-масштабирование

## Цель работы
Закрепить навыки работы с AWS EC2, Elastic Load Balancer, Auto Scaling и CloudWatch, создав отказоустойчивую и автоматически масштабируемую архитектуру.

---

# Выполнение лабораторной работы

## Шаг 1. Создание VPC и подсетей
Я создала новую VPC и настроила сетевую архитектуру. Внутри VPC я создала две публичные подсети и две приватные подсети в разных зонах доступности. Для доступа в интернет создала Internet Gateway и привязала его к VPC. В таблице маршрутов публичных подсетей настроила маршрут 0.0.0.0/0 через Internet Gateway.

---

## Шаг 2. Создание виртуальной машины и установка nginx
Я создала EC2-инстанс на основе Amazon Linux 2 (t3.micro). Включила автоматическое назначение публичного IP и создала Security Group с разрешением SSH (22) и HTTP (80).  
В поле UserData добавила скрипт автоматической установки nginx, включила Detailed Monitoring и дождалась прохождения всех Status Checks.  
Проверила работу веб-сервера через браузер.

---

## Шаг 3. Создание AMI
Из созданного EC2 я создала собственный образ AMI `project-web-server-ami`.  
AMI — это шаблон виртуальной машины. Он содержит ОС, настройки и программы. Snapshot хранит только состояние диска.  
AMI используется для Auto Scaling и быстрого развертывания.

---

## Шаг 4. Создание Launch Template
Создала Launch Template `project-launch-template`, указав созданную AMI, тип t3.micro и ту же Security Group.  
Launch Template — это шаблон конфигурации EC2, который используется Auto Scaling Group. Он новее и функциональнее Launch Configuration.

---

## Шаг 5. Создание Target Group
Создала Target Group `project-target-group`, которая будет получать HTTP-трафик от Load Balancer.  
Target Group определяет список серверов, проверяет их состояние и распределяет запросы.

---

## Шаг 6. Создание Application Load Balancer
Создала ALB `project-alb` со схемой Internet-facing.  
Internet-facing доступен из интернета, Internal — только внутри VPC.  
Указала публичные подсети, Security Group и настроила Listener 80 → Forward в Target Group.  
Проверила в Resource Map корректность связей между Listener, Rules и Target Group.

---

## Шаг 7. Создание Auto Scaling Group
Создала Auto Scaling Group `project-auto-scaling-group` на основе Launch Template.  
Выбрала две приватные подсети, так как веб-серверы должны быть скрыты от прямого доступа и работать через Load Balancer.  
Выбрала распределение по Availability Zones — Balanced best effort — для отказоустойчивости.  
Привязала ASG к созданной Target Group.  
Настроила минимальное=2, желаемое=2 и максимальное=4 количество инстансов.  
Добавила политику Target Tracking по CPU (50%), Warm-up = 60 секунд. Warm-up нужен, чтобы не учитывать метрики нового инстанса, пока он не готов.  
Включила сбор метрик ASG в CloudWatch.

---

## Шаг 8. Тестирование Application Load Balancer
Скопировала DNS Load Balancer и открыла его в браузере.  
Страница nginx отображается, а при обновлении IP меняется, так как трафик распределяется между EC2-инстансами.

---

## Шаг 9. Тестирование Auto Scaling
Перешла в CloudWatch → Alarms и увидела низкую нагрузку CPU.  
Создала нагрузку, открыв несколько вкладок по адресу `/load?seconds=60`.  
График CPU вырос, и AlarmHigh сработал. Auto Scaling автоматически создал новые EC2-инстансы, увеличив мощность системы.  
Auto Scaling обеспечивает автоматическое увеличение и уменьшение количества инстансов в зависимости от нагрузки.

---

## Шаг 10. Завершение и очистка ресурсов
Я остановила нагрузку и начала удаление ресурсов:
- удалила Load Balancer;
- удалила Target Group;
- удалила Auto Scaling Group;
- удалила EC2-инстансы;
- удалила AMI и snapshot;
- удалила Launch Template;
- удалила VPC и подсети.

Таким образом я полностью очистила инфраструктуру.

---

# Вывод
В ходе лабораторной работы я развернула отказоустойчивую и автоматически масштабируемую архитектуру в AWS, включающую EC2, Load Balancer, Target Group и Auto Scaling Group. Я научилась создавать AMI, работать с приватными и публичными подсетями, а также использовать CloudWatch для мониторинга нагрузки. Auto Scaling успешно увеличил количество серверов при повышении нагрузки, подтвердив корректность реализации архитектуры.

